{"meta":{"title":"Zou Yi's Blog","subtitle":"纵使困顿难行 亦当砥砺奋进","description":null,"author":"邹毅","url":"https://eyum.top","root":"/"},"pages":[{"title":"","date":"2020-01-13T07:44:29.948Z","updated":"2019-10-14T13:02:58.318Z","comments":true,"path":"404.html","permalink":"https://eyum.top/404.html","excerpt":"","text":"404"},{"title":"categories","date":"2019-09-23T12:23:30.000Z","updated":"2019-09-23T12:44:22.492Z","comments":false,"path":"categories/index.html","permalink":"https://eyum.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-23T12:20:17.000Z","updated":"2019-09-23T12:44:22.492Z","comments":false,"path":"tags/index.html","permalink":"https://eyum.top/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-15T14:02:43.000Z","updated":"2019-10-15T14:04:45.529Z","comments":false,"path":"friends/index.html","permalink":"https://eyum.top/friends/index.html","excerpt":"","text":"热气球公会 .post-content a{font-size: 1.5rem;}"}],"posts":[{"title":"ftp主动被动模式详解","slug":"ftp主动被动模式详解","date":"2020-01-28T13:20:33.000Z","updated":"2020-01-31T13:03:23.946Z","comments":true,"path":"2020/01/28/ftp主动被动模式详解/","link":"","permalink":"https://eyum.top/2020/01/28/ftp主动被动模式详解/","excerpt":"","text":"主动模式FTP 的传输使用的是 TCP 封包协议，FTP 的传输使用的是 TCP 封包协议。 FTP 服务器使用了两个联机，分别是命令信道与数据流通道 (ftp-data) ，这两个联机都需要经过三向交握。 主动模式 简单的联机流程就如上图所示，至于联机的步骤是这样的： 建立命令通道的联机 如上图所示，客户端会随机取一个大于 1024 以上的端口 (port AA) 来与 FTP 服务器端的 port 21 达成联机， 这个过程当然需要三向交握了！达成联机后客户端便可以透过这个联机来对 FTP 服务器下达指令， 包括查询档名、下载、上传等等指令都是利用这个通道来下达的； 通知 FTP 服务器端使用 active 且告知连接的埠号 FTP 服务器的 21 埠号主要用在命令的下达，但是当牵涉到数据流时，就不是使用这个联机了。 客户端在需要数据的情况下，会告知服务器端要用什么方式来联机，如果是主动式 (active) 联机时， 客户端会先随机启用一个端口 (图 21.1-1 当中的 port BB) ，且透过命令通道告知 FTP 服务器这两个信息，并等待 FTP 服务器的联机； FTP 服务器『主动』向客户端联机 FTP 服务器由命令通道了解客户端的需求后，会主动的由 20 这个埠号向客户端的 port BB 联机， 这个联机当然也会经过三向交握啦！此时 FTP 的客户端与服务器端共会建立两条联机，分别用在命令的下达与数据的传递。 而预设 FTP 服务器端使用的主动联机埠号就是 port 20 。 如此一来则成功的建立起『命令』与『数据传输』两个信道。同时 FTP 服务器端会使用到的端口号主要有以下两个： 命令通道的 ftp (默认为 port 21) 与 数据传输的 ftp-data (默认为port 20) 另外，很多的局域网络都会使用防火墙 (iptables) 的 NAT 功能，那么上图将变为如下所示： 主动模式_NAT 其联机的步骤是这样的： 用户与服务器间命令信道的建立： 因为 NAT 会主动的记录由内部送往外部的联机信息，而由于命令信道的建立是由客户端向服务器端联机的， 因此这一条联机可以顺利的建立起来的； 用户与服务器间数据信道建立时的通知： 同样的，客户端主机会先启用 port BB ，并透过命令通道告知 FTP 服务器，且等待服务器端的主动联机； 服务器主动连到 NAT 等待转递至客户端的联机问题： 但是由于透过 NAT 的转换后，FTP 服务器只能得知 NAT 的 IP 而不是客户端的 IP ， 因此 FTP 服务器会以 port 20 主动的向 NAT 的 port BB 发送主动联机的要求。 但你的 NAT 并没有启动 port BB 来监听 FTP 服务器的联机。 由此可见，在 FTP 的主动式联机当中，NAT 将会被视为客户端，但 NAT 其实并非客户端， 这就造成问题了。如果你曾经在 IP 分享器后面连接某些 FTP 服务器时，可能偶尔会发现明明就连接上 FTP 服务器了 (命令通道已建立)，但是就是无法取得文件名的列表，而是在超过一段时间后显示『 Can’t build data connection: Connection refused，无法进行数据传输』之类的讯息， 那肯定就是这个原因所造成的困扰了。 那有没有办法可以克服这个问题呢？难道真的在 Linux NAT 后面就一定无法使用 FTP 吗？当然不是！ 目前有两个简易的方法可以克服这个问题： 使用 iptables 所提供的 FTP 侦测模块： 其实 iptables 早就提供了许多好用的模块了，这个 FTP 当然不会被错过！ 你可以使用 modprobe 这个指令来加载 ipconntrack_ftp 及 ip_nat_ftp 等模块，这几个模块会主动的分析『目标是 port 21 的联机』信息， 所以可以得到 port BB 的资料，此时若接受到 FTP 服务器的主动联机，就能够将该封包导向正确的后端主机了！ ^^ 不过，如果你链接的目标 FTP 服务器他的命令通道默认端口号并非标准的 21 埠号时 (例如某些地下 FTP 服务器)， 那么这两个模块就无法顺利解析出来了，这样说，理解吗？ 客户端选择被动式 (Passive) 联机模式： 除了主动式联机之外，FTP 还提供一种称为被动式联机的模式，什么是被动式呢？ 既然主动式是由服务器向客户端联机，反过来讲，被动式就是由客户端向服务器端发起联机的啰！ 既然是由客户端发起联机的，那自然就不需要考虑来自 port 20 的联机啦！关于被动式联机模式将在以下介绍。 被动模式同样，我们可以使用底下的图示来作个简略的介绍： 被动模式 其数据流联机流程如下： 用户与服务器建立命令信道： 同样的需要建立命令通道，透过三向交握就可以建立起这个通道了。 客户端发出 PASV 的联机要求： 当有使用数据信道的指令时，客户端可透过命令通道发出 PASV 的被动式联机要求 (Passive 的缩写)， 并等待服务器的回应； FTP 服务器启动数据端口，并通知客户端联机： 如果你的 FTP 服务器是能够处理被动式联机的，此时 FTP 服务器会先启动一个端口在监听。 这个端口号码可能是随机的，也可以自定义某一范围的端口，端看你的 FTP 服务器软件而定。 然后你的 FTP 服务器会透过命令通道告知客户端该已经启动的端口 (图中的 port PASV)， 并等待客户端的联机。 客户端随机取用大于 1024 的端口号进行连接： 然后你的客户端会随机取用一个大于 1024 的端口号来对主机的 port PASV 联机。 如果一切都顺利的话，那么你的 FTP 数据就可以透过 port BB 及 port PASV 来传送了。 PS: 本文来源于鸟哥的Linux私房菜","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"ftp","slug":"ftp","permalink":"https://eyum.top/tags/ftp/"}]},{"title":"ftp nologin用户","slug":"ftp-nologin用户","date":"2020-01-28T13:11:03.000Z","updated":"2020-01-28T14:38:00.880Z","comments":true,"path":"2020/01/28/ftp-nologin用户/","link":"","permalink":"https://eyum.top/2020/01/28/ftp-nologin用户/","excerpt":"","text":"ftp nologin用户 环境为：vsftpd: version 3.0.2 最近需要捣鼓下FTP服务器，发现如果系统用户的登录shell设置为/sbin/nologin，就无法使用FTP服务,报错如下： ftp.png 原因是，ftp会根据/etc/shells这个文件来判断一个用户是否是有效用户，并阻止那些shell不在/etc/shells里的用户登陆。所以如果ftp用户的登录shell为/sbin/nologin,则需要添加到/etc/shells文件里面，或者可以通过禁用PAM模块，注释/etc/pam.d/vsftpd文件内的auth required pam_shells.so 另外，出于安全的考虑，root用户是不能登录ftp的，如果有这个需求的话，可以将/etc/vsftpd/ftpusers文件内的root注释","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"ftp","slug":"ftp","permalink":"https://eyum.top/tags/ftp/"}]},{"title":"常用数学符号","slug":"常用数学符号","date":"2020-01-03T14:08:22.000Z","updated":"2020-01-03T15:57:16.985Z","comments":true,"path":"2020/01/03/常用数学符号/","link":"","permalink":"https://eyum.top/2020/01/03/常用数学符号/","excerpt":"","text":"符号 收录一些常用的数学符号的LaTeX，方便日常使用（持续更新……） 希腊字母 希腊字母小写、大写 LaTeX 希腊字母小写、大写 LaTeX $\\alpha\\ A$ \\alpha A $\\nu\\ N$ \\nu N $\\beta\\ B$ \\beta B $\\xi\\ \\Xi$ \\xi \\Xi $\\gamma\\ \\Gamma$ \\gamma \\Gamma $\\omicron\\ O$ \\omicron O $\\delta\\ \\Delta$ \\delta \\Delta $\\pi\\ \\Pi$ \\pi \\Pi $\\epsilon\\ \\varepsilon\\ E $ \\epsilon \\varepsilon E $\\rho\\ \\varrho\\ P$ \\rho \\varrho P $\\zeta\\ Z$ \\zeta Z $\\sigma\\ \\Sigma$ \\sigma \\Sigma $\\eta\\ H $ \\eta H $\\tau\\ T$ \\tau T $\\theta\\ \\vartheta\\ \\Theta$ \\theta \\vartheta \\Theta $\\upsilon\\ \\Upsilon$ \\upsilon \\Upsilon $\\iota\\ I $ \\iota I $\\phi\\ \\varphi\\ \\Phi$ \\phi \\varphi \\Phi $\\kappa\\ K$ \\kappa K $\\chi\\ x\\ X$ \\chi x X $\\lambda\\ \\Lambda$ \\lambda \\Lambda $\\psi\\ \\Psi$ \\psi \\Psi $\\mu\\ M $ \\mu M $\\omega\\ \\Omega$ \\omega \\Omega 注：\\mit\\Gamma 表斜体 $\\mit\\Gamma$ 数和数组 符号 LaTeX 概念 符号 LaTeX 概念 $a$ a 标量（整数或实数） $e^{(i)}$ e^{(i)} 标准基向量[0,…,0,1,0,…,0]，其中索引 $i$ 处值为1 $\\boldsymbol{a}$ \\boldsymbol{a} 向量 ${\\rm diag}(a)$ {\\rm diag}(a) 对角方阵，其中对角元素由 $a$ 给定 $A$ A 矩阵 $\\rm{a}$ \\rm{a} 标量随机变量 $\\rm{\\textbf{A}}$ \\rm{\\textbf{A}} 张量 $\\textbf{a}$ \\textbf{a} 向量随机变量 $I_n$ I_n $n$ 行 $n$ 列的单位矩阵 $\\rm{A}$ \\rm{A} 矩阵随机变量 $I$ I 维度蕴含于上下文的单位矩阵 代数","categories":[{"name":"Paper","slug":"Paper","permalink":"https://eyum.top/categories/Paper/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"https://eyum.top/tags/LaTeX/"}]},{"title":"机器学习中的数学","slug":"机器学习中的数学","date":"2020-01-03T04:56:23.000Z","updated":"2020-01-08T06:21:29.739Z","comments":true,"path":"2020/01/03/机器学习中的数学/","link":"","permalink":"https://eyum.top/2020/01/03/机器学习中的数学/","excerpt":"","text":"机器学习中的数学 平方误差 梯度下降法 矩阵求解 极大似然估计 熵的原理 启发式算法 平方误差误差，指的是某个变量的错误程度，直白来说，误差就是“真实值-预测值”。那么，平方误差通过计算每一个样本误差的平方，再求和。即平方误差的公式是 $L=\\sum_{i=1}^{N}(\\hat{y}_{i}-y_{i})^{2}$。其中，$\\hat{y}_{i}$ 为第 $i$ 个样本的真实值，$y_{i}$ 为第 $i$ 个样本的预测值。 梯度下降法机器学习中的所有算法都依赖于最小化或最大化某一个函数，我们称之为“目标函数”。最小化的这组函数被称为“损失函数”。损失函数是衡量预测模型预测期望结果表现的指标。寻找函数最小值的最常用方法是“梯度下降”。把损失函数想象成起伏的山脉，梯度下降就像从山顶滑下，目的是到达山脉的最低点。关于求解极小值问题，我们常用的方法是代数法和求导法： 代数法：$y=x^{2}+2x+3$ 可以化为 $y=(x+1)^{2}+2$，那么其最小值 $x$ = -1时取到。 求导法：令 $y=x^{2}+2x+3$ 的导数：$\\frac{\\mathrm{d}y}{\\mathrm{d}x}=2x+2=0$。解得 $x$ = -1时 $y$ 取得最小值。 但是，求解函数$y=x^{2}+2x+e^{x}+3$的极小值时，代数法和求导法都不再适用，此时就需要用更通用的极值求解方法，这就是梯度下降法。首先，梯度 (gradient) 是一阶偏导组成的向量，其表示函数变化率最快的方向，是相对于一个向量求导的导数： $f$ 的梯度是包含所有偏导数的向量，记为 ${\\nabla}_{x}f(x)$。梯度的第 $i$ 个元素是 $f$ 关于 $x_i$ 的偏导数。在多维情况下，临界点是梯度中的所有元素都为 $0$ 的点。在 $u$(单位向量)方向的方向导数 (directional derivative) 是函数 $f$ 在 $u$ 方向的斜率。换句话说，方向导数是函数 $f(x+{\\alpha}u)$ 关于 $\\alpha$ 的导数（在 $\\alpha$ = 0 时取到）。使用链式法则，我们可以看到当 $\\alpha$ = 0 时，$\\frac{\\partial}{\\partial \\alpha}f(x+{\\alpha}u)=u^\\top{\\nabla}_{x}f(x)$。为了最小化 $f$,我们希望找到使 $f$ 下降得最快的方向。计算方向导数为：$$\\min_{u,u^\\top u=1}u^\\top{\\nabla}_{x}f(x)$$$$=\\min_{u,u^\\top u=1}\\left|\\left|u\\right|\\right|_2 \\left|\\left|{\\nabla}_{x}f(x)\\right|\\right|_2 \\cos \\theta$$其中 $\\theta$ 是 $u$ 与梯度的夹角。将 $ \\left|\\left|u\\right|\\right|_2 =1$ 带入，并忽略与 $u$ 无关的项，就能简化得到 $\\min_u \\cos \\theta$。这在 $u$ 与梯度方向相反时取得最小。换句话说，梯度向量指向上坡，负梯度向量指向下坡。我们在负梯度方向上移动可以减小 $f$。这就是梯度下降法(gradient descent)，也称最速下降法(method of steepest descent)。最速下降法建议新的点为$$x’=x-\\epsilon{\\nabla}_{x}f(x)$$其中 $\\epsilon$ 为学习率(learning rate)，是一个确定步长大小的正标量。我们可以通过几种不同的方式选择 $\\epsilon$。普遍的方式是选择一个小常数。有时我们通过计算，选择使方向导数消失的步长。还有一种方法是根据几个 $\\epsilon$ 计算 $f(x-\\epsilon{\\nabla}_{x}f(x))$,并选择其中能产生最小目标函数值的 $\\epsilon$。这种策略是线搜索。回到上面的题，求 $y=x^{2}+2x+e^{x}+3$ 的最小值。首先我们先随机初始化一个点 $x_0=0$ ，设置学习率 $\\epsilon=0.3$,其次，计算梯度 ${\\nabla}_{x}f(x)=\\frac{\\mathrm{d}y}{\\mathrm{d}x}=2x+2+e^x$。之后的计算交给MATLAB，代码如下： 12345678910111213x = 0.0; %初始化值c = 0.5; %设置学习率fprintf(&apos;n\\t\\t更新前的点\\t\\t梯度\\t\\t更新后的点\\n&apos;);for n = 1 : 10 xold = x; %本次循环前的 xt 值 grad = 2*x+2+exp(x); %梯度 xnew = x - c*grad; %梯度下降法更新后的点 fprintf(&apos;%d\\t\\t%6.2f\\t\\t%6.2f\\t\\t%6.2f\\n&apos;,n,xold,grad,xnew); x = xnew;end 得到结果如下： n 更新前的点 梯度 更新后的点 1 0.00 3.00 -1.50 2 -1.50 -0.78 -1.11 3 -1.11 -0.11 -1.16 4 -1.16 -0.02 -1.16 5 -1.16 -0.00 -1.16 6 -1.16 -0.00 -1.16 7 -1.16 -0.00 -1.16 8 -1.16 -0.00 -1.16 9 -1.16 -0.00 -1.16 10 -1.16 -0.00 -1.16 从上表中可以看到，在第4次循环后，$x’$ 的值不再改变，收敛于 $x=-1.16$，即，当 $x=-1.16$ 时，y取得最小值为 $y_{min}=(-1.16)^2+2*(-1.16)+e^{-1.16}+3=2.33908$ 矩阵求解(待更新)极大似然估计熵的原理启发式算法","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://eyum.top/categories/Algorithm/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"https://eyum.top/tags/Machine-learning/"},{"name":"Math","slug":"Math","permalink":"https://eyum.top/tags/Math/"},{"name":"Deep learning","slug":"Deep-learning","permalink":"https://eyum.top/tags/Deep-learning/"}]},{"title":"Android-action","slug":"Android-action","date":"2019-10-16T14:40:39.000Z","updated":"2019-10-16T14:41:19.529Z","comments":true,"path":"2019/10/16/Android-action/","link":"","permalink":"https://eyum.top/2019/10/16/Android-action/","excerpt":"","text":"编写一个MainActivity和MyService，在MainActivity中的onCreate()函数中为两个按钮分别设置点击事件监听器，点击第一个按钮启动服务弹出一个Toast显示“您点击了第一个按钮”，点击第二个按钮启动服务弹出一个Toast显示“您点击了第二个按钮”。（以action区分不同的动作） MainActivity.java 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final Button button1 = findViewById(R.id.button1); Button button2 = findViewById(R.id.button2); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this, MyService.class); intent.setAction(&quot;ACTION_BUTTON_1&quot;); startService(intent); &#125; &#125;); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this, MyService.class); intent.setAction(&quot;ACTION_BUTTON_2&quot;); startService(intent); &#125; &#125;); &#125;&#125; MyService.java 1234567891011121314151617181920public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; String intentAction = intent.getAction(); if (intentAction.equals(&quot;ACTION_BUTTON_1&quot;)) &#123; Toast.makeText(this, &quot;您点击了第一个按钮&quot;, Toast.LENGTH_LONG).show(); &#125; else if (intentAction.equals(&quot;ACTION_BUTTON_2&quot;)) &#123; Toast.makeText(this, &quot;您点击了第二个按钮&quot;, Toast.LENGTH_LONG).show(); &#125; return super.onStartCommand(intent, flags, startId); &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://eyum.top/tags/Android/"}]},{"title":"Desktop icons don't appear","slug":"Desktop-icons-don-t-appear","date":"2019-10-12T14:59:22.000Z","updated":"2020-01-28T12:55:40.105Z","comments":true,"path":"2019/10/12/Desktop-icons-don-t-appear/","link":"","permalink":"https://eyum.top/2019/10/12/Desktop-icons-don-t-appear/","excerpt":"","text":"Debian 10 无桌面图标 (PS : 本文嵌入了一段 YouTube 视频，自行科学上网)环境如下:OS : Debian 10GNOME : 3.30.2 Debian 10 刚安装完后是这样的，未显示桌面图标：![Debian 10.png](Debian 10.png)最终在这篇文章中找到了原因：原文链接 No-desktop-icons.png 具体原因为，之前 GNOME 的 Desktop 是由 Nautilus 管理的，而现在开发者不维护了。在 YouTube 上找到了解决方案：视频链接 可以通过 Firefox 插件来解决，如下图： Applications-Menu.png Debian-10.png","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://eyum.top/tags/Linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-23T12:44:22.000Z","updated":"2020-01-28T13:02:30.806Z","comments":true,"path":"2019/09/23/hello-world/","link":"","permalink":"https://eyum.top/2019/09/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}