{"meta":{"title":"Zou Yi's Blog","subtitle":"纵使困顿难行 亦当砥砺奋进","description":null,"author":"邹毅","url":"https://eyum.top","root":"/"},"pages":[{"title":"categories","date":"2019-09-23T12:23:30.000Z","updated":"2019-09-23T12:44:22.492Z","comments":false,"path":"categories/index.html","permalink":"https://eyum.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-23T12:20:17.000Z","updated":"2019-09-23T12:44:22.492Z","comments":false,"path":"tags/index.html","permalink":"https://eyum.top/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-15T14:02:43.000Z","updated":"2019-10-15T14:04:45.529Z","comments":false,"path":"friends/index.html","permalink":"https://eyum.top/friends/index.html","excerpt":"","text":"热气球公会 .post-content a{font-size: 1.5rem;}"}],"posts":[{"title":"去除kindle电子书DRM锁","slug":"去除kindle电子书DRM锁","date":"2020-04-23T14:29:00.000Z","updated":"2020-07-15T01:40:46.458Z","comments":true,"path":"2020/04/23/去除kindle电子书DRM锁/","link":"","permalink":"https://eyum.top/2020/04/23/去除kindle电子书DRM锁/","excerpt":"","text":"事先声明：本教程所有书籍均为本人在亚马逊上购买，为转换格式、方便阅读及分享，才需要去除 DRM 版权保护。请您尊重知识产权保护，支持正版，为您点赞！ 什么是 DRM 版权保护Wikipedia contributors. (2020, July 12). Digital rights management. In Wikipedia, The Free Encyclopedia. Retrieved 12:45, July 14, 2020, from https://en.wikipedia.org/w/index.php?title=Digital_rights_management&amp;oldid=967384596 DRM，英文全称 Digital rights management，中文翻译为数字版权管理，是一系列访问控制技术，通常用于控制数字内容和设备在被销售之后的使用过程。DRM 有时也称为拷贝保护、复制控制、技术保护措施等，但这些叫法存在争议。许多数字出版社和软件厂商都使用了DRM，例如亚马逊、AT&amp;T、AOL、Apple Inc.、Netflix、Google、BBC、微软、Sony、Valve Corporation等。 准备工作 老版的 Kindle 软件 calibre DeDRM_tools 本文使用的是 Kindle for PC v1.17，最新版的没法用，官网已经移除了下载链接，可以去第三方下，下载地址： Windows http://onlineconverter.epubor.com/KindleForPC-installer-1.17.44170.exe http://download.epubor.com/KindleForPC-installer-1.17.44170.exe Mac http://onlineconverter.epubor.com/KindleForMac1171.dmg.zip http://download.epubor.com/KindleForMac1171.dmg.zip calibre 官网下载页面：https://calibre-ebook.com/download DeDRM_tools，Github Releases 下载页面：https://github.com/apprenticeharper/DeDRM_tools/releases 安装calibre 的安装不再赘述，其本书不支持去除 DRM,首先需要安装相应插件 —— DeDRM。从 DeDRM_tools 的 releases 中下载最新的 zip 包并解压。在首选项-高级选项那里找到插件 接着，选择从文件加载插件，选择解压后得到的 DeDRM_plugin.zip 文件 calibre 会有一些安全警告，先忽略。安装好后需要重启 calibre。 下载电子书从 Kindle 的图书馆那下载你的电子书，这里以这本贝叶斯为例 下载后从磁盘找到相应的 azw 文件，如果不清楚是哪个，可以看文件的修改日期 把刚才那个文件导入到 calibre，如果右边的格式为 AZW3，则 DRM 已被去除，反正如果还是 AZW 格式，则失败 去除 DRM 后就可以对其进行转换格式等操作，如以下就转换成了 EPUB 格式。","categories":[{"name":"Sharing","slug":"Sharing","permalink":"https://eyum.top/categories/Sharing/"}],"tags":[{"name":"Kindle","slug":"Kindle","permalink":"https://eyum.top/tags/Kindle/"}]},{"title":"pytorch 自定义Dataset","slug":"pytorch-自定义Dataset","date":"2020-04-08T11:44:29.000Z","updated":"2020-07-08T14:57:42.024Z","comments":true,"path":"2020/04/08/pytorch-自定义Dataset/","link":"","permalink":"https://eyum.top/2020/04/08/pytorch-自定义Dataset/","excerpt":"","text":"有空写","categories":[],"tags":[]},{"title":"TensorFlow自定义优化器","slug":"TensorFlow自定义优化器","date":"2020-04-05T00:55:59.000Z","updated":"2020-07-08T14:57:19.994Z","comments":true,"path":"2020/04/05/TensorFlow自定义优化器/","link":"","permalink":"https://eyum.top/2020/04/05/TensorFlow自定义优化器/","excerpt":"","text":"有空写","categories":[],"tags":[]},{"title":"Tensorflow Optimizer 梯度修正","slug":"Tensorflow-Optimizer-梯度修正","date":"2020-04-03T12:18:20.000Z","updated":"2020-07-08T14:57:00.740Z","comments":true,"path":"2020/04/03/Tensorflow-Optimizer-梯度修正/","link":"","permalink":"https://eyum.top/2020/04/03/Tensorflow-Optimizer-梯度修正/","excerpt":"","text":"有空写","categories":[],"tags":[]},{"title":"Tensorflow 优化器详解","slug":"Tensorflow-优化器详解","date":"2020-03-28T09:50:42.000Z","updated":"2020-07-08T14:57:10.364Z","comments":true,"path":"2020/03/28/Tensorflow-优化器详解/","link":"","permalink":"https://eyum.top/2020/03/28/Tensorflow-优化器详解/","excerpt":"","text":"有空写","categories":[],"tags":[]},{"title":"Precision、Recall","slug":"Precision、Recall","date":"2020-03-26T02:33:00.000Z","updated":"2020-07-08T14:57:32.522Z","comments":true,"path":"2020/03/26/Precision、Recall/","link":"","permalink":"https://eyum.top/2020/03/26/Precision、Recall/","excerpt":"","text":"有空写","categories":[],"tags":[]},{"title":"Chrome OS 提升JetBrains系列流畅度","slug":"ChromeOS-提升JetBrains系列流畅度","date":"2020-03-08T11:55:27.000Z","updated":"2020-07-21T16:54:55.321Z","comments":true,"path":"2020/03/08/ChromeOS-提升JetBrains系列流畅度/","link":"","permalink":"https://eyum.top/2020/03/08/ChromeOS-提升JetBrains系列流畅度/","excerpt":"","text":"机型 Version pixelbook 2017 79.0.3945.123 (Official Build) (64-bit) 原因Chrome OS上提供了一个基于 Debian 的 Linux 容器 Crostini，在启用后可以运行 Jetbrain 全家桶，但是 PyCharm、IntelliJ 等，非常卡，顺带一提，同样系列的 Android Studio 就完全没有这个问题。 解决首先，以 PyCharm 为例，在运行该任务时进行了层层封装： 1Chrome OS( Crostini( JVM( PyCharm ) ) ) 这才卡成 PPT，那么可以通过切换 IDE 的 JRE 使其变得流畅。 启用首先用 chrome 浏览器打开 chrome://flags，找到 Crostini GPU Support ，启用Linux容器应用的GPU支持 Crostini GPU Support 同时将 Scheduler Configuration 选项设置为 Enable Hyper-thread（启用超线程），完成后重启你的设备。 Scheduler Configuration Runtime打开 PyCharm，进入 Settings&gt;Plugins，在 Marketplace 中搜索插件 Choose Runtime，下载，完成后重启 IDE。 Plugins 再次打开 PyCharm，双击Shift键呼出全局搜索栏， 搜索 “Choose Runtime” 选择相应的 JRE 并安装，之后重启 IDE 即可。","categories":[{"name":"Server","slug":"Server","permalink":"https://eyum.top/categories/Server/"}],"tags":[{"name":"Chrome OS","slug":"Chrome-OS","permalink":"https://eyum.top/tags/Chrome-OS/"},{"name":"Crostini","slug":"Crostini","permalink":"https://eyum.top/tags/Crostini/"}]},{"title":"Django 跨域问题","slug":"Django-跨域问题","date":"2020-03-03T08:59:11.000Z","updated":"2020-07-08T14:47:11.603Z","comments":true,"path":"2020/03/03/Django-跨域问题/","link":"","permalink":"https://eyum.top/2020/03/03/Django-跨域问题/","excerpt":"","text":"起因Django 项目，在 html 页面中使用了 frameset 以及 frame 标签。 报错运行结果： f12 调试，看到一下报错。 123Refused to display &apos;http://127.0.0.1:8000/top.html&apos; in a frame because it set &apos;X-Frame-Options&apos; to &apos;deny&apos;.Refused to display &apos;http://127.0.0.1:8000/left.html&apos; in a frame because it set &apos;X-Frame-Options&apos; to &apos;deny&apos;.Refused to display &apos;http://127.0.0.1:8000/news.html&apos; in a frame because it set &apos;X-Frame-Options&apos; to &apos;deny&apos;. 原因主要是 Django 将页面通过iframe显示在 app 页面中。而在这个页面中 request header 中多出响应头 X-Frame-Options 值默认为 deny，于是报出如下错误。 解决针对每个 view 设置可以设置 view 响应头为 exempt，一共有以下三种： 123@xframe_options_deny #不允许在frame中展示@xframe_options_sameorigin #允许在通域名的frame中展示@xframe_options_exempt #去掉iframe限制，允许iframe访问某一个views 那么，在 views.py 中对某个 view 指定即可： views.py1234567891011121314151617181920212223242526272829@xframe_options_exemptdef top(request): return render(request, 'NetEase/top.html')@xframe_options_exemptdef left(request): return render(request, 'NetEase/left.html')@xframe_options_exemptdef news(request): limit = 4 # 限制每一页显示的条目数量 article = NetEase.objects paginator = Paginator(article, limit) page_num = request.GET.get('page', 1) # 从url中获取页码参数 page_num = int(page_num) # 把当前的页码数转换为整数类型 try: loaded = paginator.page(page_num) # 获取当前页码的记录 except ValueError: loaded = paginator.page(1) except PageNotAnInteger: loaded = paginator.page(1) # 如果用户输入的页码不是整数时,显示第1页的内容 except EmptyPage: loaded = paginator.page(paginator.num_pages) # 如果用户输入的页码超出总页码时,显示第1页的内容 context = &#123; 'NetEase': loaded &#125; return render(request, 'NetEase/news.html', context) 效果： 针对全部页面在 settings 中设置即可。 settings.py1X_FRAME_OPTIONS = 'ALLOWALL url'","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://eyum.top/tags/Django/"}]},{"title":"Django POST 403 Forbidden","slug":"Django-POST-403-Forbidden","date":"2020-03-03T08:58:31.000Z","updated":"2020-07-14T11:26:48.838Z","comments":true,"path":"2020/03/03/Django-POST-403-Forbidden/","link":"","permalink":"https://eyum.top/2020/03/03/Django-POST-403-Forbidden/","excerpt":"","text":"原因我这边定义了一个表单，向后台提交数据，提交方式为 POST，程序出现以下问题： 出现原因出现这个报错的原因主要是跨站请求伪造。Django 框架为我们提供了一个中间件，用于处理跨站请求伪造，假如某个用户从来没有登录过我们的网站就给我们网站 post 数据，这样是会被 Django 这个中间件给阻挡，禁止请求。然后我们在开发 web 的时候可以给每一个登录的用户分配一个 token。这个 token 会被写入到用户的 cookie 文件里面。然后下次用户 post 数据的时候，就会带上这个 token。 因此如果没有 token 的用户就会被禁止 post 数据。 解决改 settings 文件注释掉 settings 文件里关于 CSRF 的验证。 settings.py 123456789MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', # POST 403 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 改 views 文件或者可以在你的 views 文件内，导入模块 from django.views.decorators.csrf import csrf_exempt，并在接收 POST 请求数据的函数前面添加修饰器 @csrf_exempt。 以上两个方法都可以让当前的 POST 不受 Django 跨站请求伪造的中间件的限制。","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://eyum.top/tags/Django/"}]},{"title":"MongoEngine读取数据库","slug":"MongoEngine读取数据库","date":"2020-02-28T07:06:33.000Z","updated":"2020-07-08T09:00:50.876Z","comments":true,"path":"2020/02/28/MongoEngine读取数据库/","link":"","permalink":"https://eyum.top/2020/02/28/MongoEngine读取数据库/","excerpt":"","text":"需求分析将 MongoDB 数据库内的数据读取出来，并展示在前端页面。 在 settings 中建立连接连结信息写在 settings.py 中，同时注释原有的 sqlite 数据库连接。 setting.py1234567891011# 指明要连接的数据库mongo_con = mongoengine.connect('***', host='your ip address', port=27017, username=\"***\", password=\"***\")collection = str(datetime.date.today())mongo_db = mongo_con[collection]DATABASES = &#123; 'default': &#123; # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125; # 注释掉默认数据库连接 在 models 中声明需要查询的集合以及字段声明需要查询的字段，与你的数据库表结构对应。 models.py123456789101112131415161718192021222324import datetimefrom mongoengine import *connect('163news', host='117.78.0.242', port=27017, username=\"zouyi\", password=\"980718\") # 指明要连接的数据库class NetEase(Document): _id = ObjectIdField(required=True) url = StringField(required=True) title = StringField(required=True) date = StringField(required=True) content = StringField(required=True) abstract = StringField(required=True) id = IntField(required=True) comments = StringField(required=True) heat = IntField(required=True) collection = str(datetime.date.today()) meta = &#123;'collection': collection&#125;# for i in NetEase.objects[:20]: # 测试是否连接成功# print(str(i.id) + \": \" + i.content[:20]) 在 views 内获取相应的信息同时在 views.py 中获取所需信息，并使用 paginator 分页，通过 render 传给html。 分页可查看 Django使用分页器 views.py123456789101112131415161718192021222324252627from django.core.paginator import Paginator, PageNotAnInteger, EmptyPagefrom django.shortcuts import render# Create your views here.from django.views.decorators.clickjacking import xframe_options_exemptfrom NetEase.models import NetEase@xframe_options_exemptdef news(request): limit = 4 # 限制每一页显示的条目数量 article = NetEase.objects paginator = Paginator(article, limit) page_num = request.GET.get('page', 1) # 从url中获取页码参数 page_num = int(page_num) # 把当前的页码数转换为整数类型 try: loaded = paginator.page(page_num) # 获取当前页码的记录 except ValueError: loaded = paginator.page(1) except PageNotAnInteger: loaded = paginator.page(1) # 如果用户输入的页码不是整数时,显示第1页的内容 except EmptyPage: loaded = paginator.page(paginator.num_pages) # 如果用户输入的页码超出总页码时,显示第1页的内容 context = &#123; 'NetEase': loaded &#125; return render(request, 'NetEase/news.html', context) 对应信息展示在前端遍历查询到的数据，通过 item.xxx 加载到 html。 news.html12345678910111213141516171819202122232425262728293031&#123;% for item in NetEase %&#125; &lt;div class=\"news1\"&gt; &lt;h3&gt; &lt;div class=\"left\"&gt; &#123;# &lt;span class=\"red\"&gt;全国&lt;/span&gt;#&#125; &lt;span&gt;&#123;&#123; item.title &#125;&#125;&lt;/span&gt; &lt;span&gt;&lt;img src=\"&#123;% static 'img/new.gif' %&#125;\" alt=\"new\"/&gt;&lt;/span&gt; &lt;span class=\"ls\"&gt;[正/负面信息]&lt;/span&gt; &lt;/div&gt; &lt;span class=\"right\"&gt;0&lt;/span&gt; &lt;/h3&gt; &lt;div class=\"h3bottom1\"&gt; &lt;span class=\"feb900\"&gt;&#123;&#123; item.date &#125;&#125;&lt;/span&gt; &#123;% if item.content|length &gt;= 300 %&#125; &#123;&#123; item.content|slice:\"300\" &#125;&#125; …… &#123;% else %&#125;&#123;&#123; item.content &#125;&#125; &#123;% endif %&#125; &lt;span style=\"font-weight: bold;text-decoration: underline;\"&gt; &lt;a href=\"&#123;&#123; item.url &#125;&#125;\" target=\"_blank\"&gt;阅读原文&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"butt\"&gt; &lt;a href=\"#\"&gt;&lt;img src=\"&#123;% static 'img/xxlist_03_15.png' %&#125;\" alt=\"\"/&gt;&lt;/a&gt; &lt;a href=\"#\"&gt;&lt;img src=\"&#123;% static 'img/xxlist_03_13.png' %&#125;\" alt=\"\"/&gt;&lt;/a&gt; &lt;a href=\"#\"&gt;&lt;img src=\"&#123;% static 'img/xxlist_03_11.png' %&#125;\" alt=\"\"/&gt;&lt;/a&gt; &lt;a href=\"#\"&gt;&lt;img src=\"&#123;% static 'img/xxlist_03_09.png' %&#125;\" alt=\"\"/&gt;&lt;/a&gt; &lt;a href=\"#\"&gt;&lt;img src=\"&#123;% static 'img/xxlist_03_07.png' %&#125;\" alt=\"\"/&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; 完整效果：","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://eyum.top/tags/Django/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://eyum.top/tags/MongoDB/"}]},{"title":"Django使用分页器","slug":"Django使用分页器","date":"2020-02-28T07:03:31.000Z","updated":"2020-07-08T09:48:54.974Z","comments":true,"path":"2020/02/28/Django使用分页器/","link":"","permalink":"https://eyum.top/2020/02/28/Django使用分页器/","excerpt":"","text":"使用默认的分页器数据库内存的数据较多，读取的时候一页太长，因此需要使用分页器进行分页，在 Django 的 views 内声明。 views.py123456789101112131415161718192021222324252627from django.core.paginator import Paginator, PageNotAnInteger, EmptyPagefrom django.shortcuts import render# Create your views here.from django.views.decorators.clickjacking import xframe_options_exemptfrom NetEase.models import NetEase@xframe_options_exemptdef news(request): limit = 4 # 限制每一页显示的条目数量 article = NetEase.objects paginator = Paginator(article, limit) page_num = request.GET.get('page', 1) # 从url中获取页码参数 page_num = int(page_num) # 把当前的页码数转换为整数类型 try: loaded = paginator.page(page_num) # 获取当前页码的记录 except ValueError: loaded = paginator.page(1) except PageNotAnInteger: loaded = paginator.page(1) # 如果用户输入的页码不是整数时,显示第1页的内容 except EmptyPage: loaded = paginator.page(paginator.num_pages) # 如果用户输入的页码超出总页码时,显示第1页的内容 context = &#123; 'NetEase': loaded &#125; return render(request, 'NetEase/news.html', context) 这样，在 URL 上就可以通过 ?page=x 来访问第 x 页的数据，例如：http://127.0.0.1:8000/news.html?page=6 展示的就是第六页的数据。 上下页及跳转为了方便，在前端上做一个上下页以及跳转的按钮。 news.html12345678910111213141516171819202122232425262728&lt;div&gt; &lt;ul class=\"fy\"&gt; &#123;% if NetEase.has_previous %&#125; &lt;li&gt;&lt;a href=\"?page=&#123;&#123; NetEase.previous_page_number &#125;&#125;\"&gt; 上一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;li&gt;&#123;&#123; NetEase.number &#125;&#125; of &#123;&#123; NetEase.paginator.num_pages &#125;&#125;&lt;/li&gt; &#123;% if NetEase.has_next %&#125; &lt;li&gt;&lt;a href=\"?page=&#123;&#123; NetEase.next_page_number &#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;div class=\"tiaozhao\"&gt; &#123;# &lt;form action=\"?page=&#123;&#123; page &#125;&#125;\" method=\"post\"&gt;#&#125; &lt;label&gt; &lt;input type=\"text\" class=\"wb\" id=\"page\"/&gt; &lt;/label&gt; &lt;input type=\"submit\" class=\"tj\" value=\"跳转\" onclick=\"tz()\"/&gt; &#123;# &lt;/form&gt;#&#125; &lt;/div&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"&#123;% static 'js/nav.js' %&#125;\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; function tz() &#123; &#123;#alert(\"?page=\" + document.getElementById(\"page\").value);#&#125; window.location.href = \"?page=\" + document.getElementById(\"page\").value; &#125;&lt;/script&gt; 最终效果： Bar.png 异常输入也没问题，会跳转到第一页，代码在 views 内。","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://eyum.top/tags/Django/"}]},{"title":"MongoDB强制密码登录","slug":"MongoDB强制密码登录","date":"2020-02-26T12:23:45.000Z","updated":"2020-07-08T09:47:30.504Z","comments":true,"path":"2020/02/26/MongoDB强制密码登录/","link":"","permalink":"https://eyum.top/2020/02/26/MongoDB强制密码登录/","excerpt":"","text":"起因今天一看突然发现网站上的数据都没了，一看数据库，里面的表全没了，然后多了一张叫 RECOVERY 的 Collections，还贴心的留下了个Email：varsovie@tutanota.com 来寻求帮助，真好。 =͟͟͞͞=͟͟͞͞(●⁰ꈊ⁰● |||) shell navicat 搜了一下这个邮箱，还真有不少，找了一篇相似的：【掘金】原因是MongoDB默认直接连接，无须身份认证，而对方很可能仅仅是尝试各个IP的27017端口还好我数据库内没什么非常重要的文件，不过这次也给我提了个醒 尽量不要用默认端口（MongoDB为27017） 必要的话限制IP登录（/etc/mongod.conf 文件内 bindIp） 创建相应的管理员账户 强制要求密码登录 养成定时备份的习惯 创建相应的管理员账户MongoDB中拥有不同权限的账号，具体可以查看：【官方文档】其中常用的如下： 数据库普通用户角色 read readWrite 数据库管理员角色 dbAdmin dbOwner userAdmin 集群管理角色 clusterAdmin clusterManager clusterMonitor hostManager 备份与还原角色 backup restore 所有数据库角色（对所有数据库有效） readAnyDatabase readWriteAnyDatabase userAdminAnyDatabase dbAdminAnyDatabase 超级角色 root 内部角色 __system roles是分配用户角色的地方，主要有Read：允许用户读取指定数据库readWrite：允许用户读写指定数据库dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profileuserAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。root：只在admin数据库中可用。超级账号，超级权限 在你创建role的时候通过 role: &quot;userAdminAnyDatabase&quot; 来指定这里以创建userAdminAnyDatabase为例： 123456789101112131415161718&gt; use adminswitched to db admin&gt; db.createUser(... &#123;... user: &quot;your name&quot;,... pwd: &quot;your password&quot;,... roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]... &#125;... )Successfully added user: &#123; &quot;user&quot; : &quot;*****&quot;, &quot;roles&quot; : [ &#123; &quot;role&quot; : &quot;userAdminAnyDatabase&quot;, &quot;db&quot; : &quot;admin&quot; &#125; ]&#125; 创建成功后可以通过以下命令查看所有用户 123&gt; use adminswitched to db admin&gt; db.system.users.find() 另外，删除某个用户则为：&gt; db.system.users.remove({user:&quot;xxx&quot;}) 强制要求密码登录vim 编辑 /etc/mongod.conf，添加以下内容： 12security: authorization: enabled 保存后重启mongod，之后必须先通过 db.auth(&#39;your name&#39;,&#39;your password&#39;) 验证成功。 下次新建数据库的时候1234567891011121314151617181920212223&gt; use adminswitched to db admin&gt; db.auth(&quot;xxx&quot;,&quot;xxx&quot;) # userAdminAnyDatabase 权限的用户1&gt; use newdbswitched to db newdb&gt; db.createUser(... &#123;... user: &quot;your name&quot;,... pwd: &quot;your password&quot;,... roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;newdb&quot; &#125; ]... &#125;... )Successfully added user: &#123; &quot;user&quot; : &quot;***&quot;, &quot;roles&quot; : [ &#123; &quot;role&quot; : &quot;readWrite&quot;, &quot;db&quot; : &quot;***&quot; &#125; ]&#125;","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://eyum.top/tags/MongoDB/"}]},{"title":"Scrapy爬取的数据存入MongoDB","slug":"Scrapy爬取的数据存入MongoDB","date":"2020-02-23T04:54:24.000Z","updated":"2020-07-08T09:40:26.345Z","comments":true,"path":"2020/02/23/Scrapy爬取的数据存入MongoDB/","link":"","permalink":"https://eyum.top/2020/02/23/Scrapy爬取的数据存入MongoDB/","excerpt":"","text":"前期工作 Scrapy pymongo MongoDB 通过 pymongo 库连接 MongoDB在这里，需要用到的是 pymongo 库里面的 MongoClient，向该方法传入 MongoDB 的 IP 及 端口。 123client = pymongo.MongoClient('mongodb://your ip address:27017/')# 或者client = pymongo.MongoClient(host='your ip address', port=27017) 创建连接对象后，需要指定操作哪个数据库，这里为 pymongo 数据库。 1db = client[\"pymongo\"] 由于我的 MongoDB 数据库启用了 auth 认证，没有的跳过。需要验证密码。 1db.authenticate(\"***\", \"***\") 最后，声明了 Collection 对象，用于指定需要操作的集合。 1col = db[\"test\"] 可以往里面插入一条数据测试连接是否有效，使用 insert_one() 方法，该方法在执行后会返回一个 _id 值。运行结果为： Terminal.png Navicat.png 完整代码： 1234567891011import pymongoclient = pymongo.MongoClient('mongodb://your ip address:27017/')db = client[\"pymongo\"]db.authenticate(\"***\", \"***\")col = db[\"test\"]dict = &#123;\"id\": \"1\", \"name\": \"test\"&#125;x = col.insert_one(dict)print(x) 在 Scrapy 中使用在 Scrapy 中的数据处理部分是写在 pipelines 文件内的，与上面步骤相同，那么直接贴完整代码吧： pipelines.py12345678910111213141516171819import pymongofrom .settings import mongo_host, mongo_port, mongo_db_name, mongo_db_collectionclass NeteasePipeline(object): def __init__(self): host = mongo_host port = mongo_port dbname = mongo_db_name cname = mongo_db_collection client = pymongo.MongoClient(host=host, port=port) db = client[dbname] self.post = db[cname] db.authenticate(\"***\", \"***\") def process_item(self, item, spider): data = dict(item) self.post.insert(data) return item 其中，配置的部分我写在了 settings.py 中 settings.py123456mongo_host = \"your ip address\"mongo_port = 27017mongo_db_name = \"***\"# 日期作为collection名字date = str(datetime.date.today())mongo_db_collection = date 最后，在 settings.py 中进行相应的设置，数值越小优先级越高。 settings.py12345# Configure item pipelines# See https://docs.scrapy.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = &#123; 'netease.pipelines.NeteasePipeline': 300,&#125;","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://eyum.top/tags/MongoDB/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://eyum.top/tags/Scrapy/"}]},{"title":"MongoDB","slug":"MongoDB","date":"2020-02-21T07:25:28.000Z","updated":"2020-02-26T14:51:02.360Z","comments":true,"path":"2020/02/21/MongoDB/","link":"","permalink":"https://eyum.top/2020/02/21/MongoDB/","excerpt":"","text":"需求：将scrapy爬取的数据存入MongoDB，整理一下常用的命令，参考菜鸟教程。 MongoDB简介MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 增（有空写(￣▽￣”)）删改查","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://eyum.top/tags/MongoDB/"}]},{"title":"ftp主动被动模式详解","slug":"ftp主动被动模式详解","date":"2020-01-28T13:20:33.000Z","updated":"2020-01-31T13:03:23.946Z","comments":true,"path":"2020/01/28/ftp主动被动模式详解/","link":"","permalink":"https://eyum.top/2020/01/28/ftp主动被动模式详解/","excerpt":"","text":"主动模式FTP 的传输使用的是 TCP 封包协议，FTP 的传输使用的是 TCP 封包协议。 FTP 服务器使用了两个联机，分别是命令信道与数据流通道 (ftp-data) ，这两个联机都需要经过三向交握。 主动模式 简单的联机流程就如上图所示，至于联机的步骤是这样的： 建立命令通道的联机 如上图所示，客户端会随机取一个大于 1024 以上的端口 (port AA) 来与 FTP 服务器端的 port 21 达成联机， 这个过程当然需要三向交握了！达成联机后客户端便可以透过这个联机来对 FTP 服务器下达指令， 包括查询档名、下载、上传等等指令都是利用这个通道来下达的； 通知 FTP 服务器端使用 active 且告知连接的埠号 FTP 服务器的 21 埠号主要用在命令的下达，但是当牵涉到数据流时，就不是使用这个联机了。 客户端在需要数据的情况下，会告知服务器端要用什么方式来联机，如果是主动式 (active) 联机时， 客户端会先随机启用一个端口 (图 21.1-1 当中的 port BB) ，且透过命令通道告知 FTP 服务器这两个信息，并等待 FTP 服务器的联机； FTP 服务器『主动』向客户端联机 FTP 服务器由命令通道了解客户端的需求后，会主动的由 20 这个埠号向客户端的 port BB 联机， 这个联机当然也会经过三向交握啦！此时 FTP 的客户端与服务器端共会建立两条联机，分别用在命令的下达与数据的传递。 而预设 FTP 服务器端使用的主动联机埠号就是 port 20 。 如此一来则成功的建立起『命令』与『数据传输』两个信道。同时 FTP 服务器端会使用到的端口号主要有以下两个： 命令通道的 ftp (默认为 port 21) 与 数据传输的 ftp-data (默认为port 20) 另外，很多的局域网络都会使用防火墙 (iptables) 的 NAT 功能，那么上图将变为如下所示： 主动模式_NAT 其联机的步骤是这样的： 用户与服务器间命令信道的建立： 因为 NAT 会主动的记录由内部送往外部的联机信息，而由于命令信道的建立是由客户端向服务器端联机的， 因此这一条联机可以顺利的建立起来的； 用户与服务器间数据信道建立时的通知： 同样的，客户端主机会先启用 port BB ，并透过命令通道告知 FTP 服务器，且等待服务器端的主动联机； 服务器主动连到 NAT 等待转递至客户端的联机问题： 但是由于透过 NAT 的转换后，FTP 服务器只能得知 NAT 的 IP 而不是客户端的 IP ， 因此 FTP 服务器会以 port 20 主动的向 NAT 的 port BB 发送主动联机的要求。 但你的 NAT 并没有启动 port BB 来监听 FTP 服务器的联机。 由此可见，在 FTP 的主动式联机当中，NAT 将会被视为客户端，但 NAT 其实并非客户端， 这就造成问题了。如果你曾经在 IP 分享器后面连接某些 FTP 服务器时，可能偶尔会发现明明就连接上 FTP 服务器了 (命令通道已建立)，但是就是无法取得文件名的列表，而是在超过一段时间后显示『 Can’t build data connection: Connection refused，无法进行数据传输』之类的讯息， 那肯定就是这个原因所造成的困扰了。 那有没有办法可以克服这个问题呢？难道真的在 Linux NAT 后面就一定无法使用 FTP 吗？当然不是！ 目前有两个简易的方法可以克服这个问题： 使用 iptables 所提供的 FTP 侦测模块： 其实 iptables 早就提供了许多好用的模块了，这个 FTP 当然不会被错过！ 你可以使用 modprobe 这个指令来加载 ipconntrack_ftp 及 ip_nat_ftp 等模块，这几个模块会主动的分析『目标是 port 21 的联机』信息， 所以可以得到 port BB 的资料，此时若接受到 FTP 服务器的主动联机，就能够将该封包导向正确的后端主机了！ ^^ 不过，如果你链接的目标 FTP 服务器他的命令通道默认端口号并非标准的 21 埠号时 (例如某些地下 FTP 服务器)， 那么这两个模块就无法顺利解析出来了，这样说，理解吗？ 客户端选择被动式 (Passive) 联机模式： 除了主动式联机之外，FTP 还提供一种称为被动式联机的模式，什么是被动式呢？ 既然主动式是由服务器向客户端联机，反过来讲，被动式就是由客户端向服务器端发起联机的啰！ 既然是由客户端发起联机的，那自然就不需要考虑来自 port 20 的联机啦！关于被动式联机模式将在以下介绍。 被动模式同样，我们可以使用底下的图示来作个简略的介绍： 被动模式 其数据流联机流程如下： 用户与服务器建立命令信道： 同样的需要建立命令通道，透过三向交握就可以建立起这个通道了。 客户端发出 PASV 的联机要求： 当有使用数据信道的指令时，客户端可透过命令通道发出 PASV 的被动式联机要求 (Passive 的缩写)， 并等待服务器的回应； FTP 服务器启动数据端口，并通知客户端联机： 如果你的 FTP 服务器是能够处理被动式联机的，此时 FTP 服务器会先启动一个端口在监听。 这个端口号码可能是随机的，也可以自定义某一范围的端口，端看你的 FTP 服务器软件而定。 然后你的 FTP 服务器会透过命令通道告知客户端该已经启动的端口 (图中的 port PASV)， 并等待客户端的联机。 客户端随机取用大于 1024 的端口号进行连接： 然后你的客户端会随机取用一个大于 1024 的端口号来对主机的 port PASV 联机。 如果一切都顺利的话，那么你的 FTP 数据就可以透过 port BB 及 port PASV 来传送了。 PS: 本文来源于鸟哥的Linux私房菜","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"ftp","slug":"ftp","permalink":"https://eyum.top/tags/ftp/"}]},{"title":"ftp nologin用户","slug":"ftp-nologin用户","date":"2020-01-28T13:11:03.000Z","updated":"2020-01-28T14:38:00.880Z","comments":true,"path":"2020/01/28/ftp-nologin用户/","link":"","permalink":"https://eyum.top/2020/01/28/ftp-nologin用户/","excerpt":"","text":"ftp nologin用户 环境为：vsftpd: version 3.0.2 最近需要捣鼓下FTP服务器，发现如果系统用户的登录shell设置为/sbin/nologin，就无法使用FTP服务,报错如下： ftp.png 原因是，ftp会根据/etc/shells这个文件来判断一个用户是否是有效用户，并阻止那些shell不在/etc/shells里的用户登陆。所以如果ftp用户的登录shell为/sbin/nologin,则需要添加到/etc/shells文件里面，或者可以通过禁用PAM模块，注释/etc/pam.d/vsftpd文件内的auth required pam_shells.so 另外，出于安全的考虑，root用户是不能登录ftp的，如果有这个需求的话，可以将/etc/vsftpd/ftpusers文件内的root注释","categories":[{"name":"Software","slug":"Software","permalink":"https://eyum.top/categories/Software/"}],"tags":[{"name":"ftp","slug":"ftp","permalink":"https://eyum.top/tags/ftp/"}]},{"title":"常用数学符号","slug":"常用数学符号","date":"2020-01-03T14:08:22.000Z","updated":"2020-01-03T15:57:16.985Z","comments":true,"path":"2020/01/03/常用数学符号/","link":"","permalink":"https://eyum.top/2020/01/03/常用数学符号/","excerpt":"","text":"符号 收录一些常用的数学符号的LaTeX，方便日常使用（持续更新……） 希腊字母 希腊字母小写、大写 LaTeX 希腊字母小写、大写 LaTeX $\\alpha\\ A$ \\alpha A $\\nu\\ N$ \\nu N $\\beta\\ B$ \\beta B $\\xi\\ \\Xi$ \\xi \\Xi $\\gamma\\ \\Gamma$ \\gamma \\Gamma $\\omicron\\ O$ \\omicron O $\\delta\\ \\Delta$ \\delta \\Delta $\\pi\\ \\Pi$ \\pi \\Pi $\\epsilon\\ \\varepsilon\\ E $ \\epsilon \\varepsilon E $\\rho\\ \\varrho\\ P$ \\rho \\varrho P $\\zeta\\ Z$ \\zeta Z $\\sigma\\ \\Sigma$ \\sigma \\Sigma $\\eta\\ H $ \\eta H $\\tau\\ T$ \\tau T $\\theta\\ \\vartheta\\ \\Theta$ \\theta \\vartheta \\Theta $\\upsilon\\ \\Upsilon$ \\upsilon \\Upsilon $\\iota\\ I $ \\iota I $\\phi\\ \\varphi\\ \\Phi$ \\phi \\varphi \\Phi $\\kappa\\ K$ \\kappa K $\\chi\\ x\\ X$ \\chi x X $\\lambda\\ \\Lambda$ \\lambda \\Lambda $\\psi\\ \\Psi$ \\psi \\Psi $\\mu\\ M $ \\mu M $\\omega\\ \\Omega$ \\omega \\Omega 注：\\mit\\Gamma 表斜体 $\\mit\\Gamma$ 数和数组 符号 LaTeX 概念 符号 LaTeX 概念 $a$ a 标量（整数或实数） $e^{(i)}$ e^{(i)} 标准基向量[0,…,0,1,0,…,0]，其中索引 $i$ 处值为1 $\\boldsymbol{a}$ \\boldsymbol{a} 向量 ${\\rm diag}(a)$ {\\rm diag}(a) 对角方阵，其中对角元素由 $a$ 给定 $A$ A 矩阵 $\\rm{a}$ \\rm{a} 标量随机变量 $\\rm{\\textbf{A}}$ \\rm{\\textbf{A}} 张量 $\\textbf{a}$ \\textbf{a} 向量随机变量 $I_n$ I_n $n$ 行 $n$ 列的单位矩阵 $\\rm{A}$ \\rm{A} 矩阵随机变量 $I$ I 维度蕴含于上下文的单位矩阵 代数","categories":[{"name":"Paper","slug":"Paper","permalink":"https://eyum.top/categories/Paper/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"https://eyum.top/tags/LaTeX/"}]},{"title":"机器学习中的数学","slug":"机器学习中的数学","date":"2020-01-03T04:56:23.000Z","updated":"2020-07-08T09:16:32.011Z","comments":true,"path":"2020/01/03/机器学习中的数学/","link":"","permalink":"https://eyum.top/2020/01/03/机器学习中的数学/","excerpt":"","text":"机器学习中的数学 平方误差 梯度下降法 矩阵求解 极大似然估计 熵的原理 启发式算法 平方误差误差，指的是某个变量的错误程度，直白来说，误差就是“真实值-预测值”。那么，平方误差通过计算每一个样本误差的平方，再求和。即平方误差的公式是 $L=\\sum_{i=1}^{N}(\\hat{y}_{i}-y_{i})^{2}$。其中，$\\hat{y}_{i}$ 为第 $i$ 个样本的真实值，$y_{i}$ 为第 $i$ 个样本的预测值。 梯度下降法机器学习中的所有算法都依赖于最小化或最大化某一个函数，我们称之为“目标函数”。最小化的这组函数被称为“损失函数”。损失函数是衡量预测模型预测期望结果表现的指标。寻找函数最小值的最常用方法是“梯度下降”。把损失函数想象成起伏的山脉，梯度下降就像从山顶滑下，目的是到达山脉的最低点。关于求解极小值问题，我们常用的方法是代数法和求导法： 代数法：$y=x^{2}+2x+3$ 可以化为 $y=(x+1)^{2}+2$，那么其最小值 $x$ = -1时取到。 求导法：令 $y=x^{2}+2x+3$ 的导数：$\\frac{\\mathrm{d}y}{\\mathrm{d}x}=2x+2=0$。解得 $x$ = -1时 $y$ 取得最小值。 但是，求解函数$y=x^{2}+2x+e^{x}+3$的极小值时，代数法和求导法都不再适用，此时就需要用更通用的极值求解方法，这就是梯度下降法。首先，梯度 (gradient) 是一阶偏导组成的向量，其表示函数变化率最快的方向，是相对于一个向量求导的导数： $f$ 的梯度是包含所有偏导数的向量，记为 ${\\nabla}_{x}f(x)$。梯度的第 $i$ 个元素是 $f$ 关于 $x_i$ 的偏导数。在多维情况下，临界点是梯度中的所有元素都为 $0$ 的点。在 $u$(单位向量)方向的方向导数 (directional derivative) 是函数 $f$ 在 $u$ 方向的斜率。换句话说，方向导数是函数 $f(x+{\\alpha}u)$ 关于 $\\alpha$ 的导数（在 $\\alpha$ = 0 时取到）。使用链式法则，我们可以看到当 $\\alpha$ = 0 时，$\\frac{\\partial}{\\partial \\alpha}f(x+{\\alpha}u)=u^\\top{\\nabla}_{x}f(x)$。为了最小化 $f$,我们希望找到使 $f$ 下降得最快的方向。计算方向导数为：$$\\min_{u,u^\\top u=1}u^\\top{\\nabla}_{x}f(x)$$$$=\\min_{u,u^\\top u=1}\\left|\\left|u\\right|\\right|_2 \\left|\\left|{\\nabla}_{x}f(x)\\right|\\right|_2 \\cos \\theta$$其中 $\\theta$ 是 $u$ 与梯度的夹角。将 $ \\left|\\left|u\\right|\\right|_2 =1$ 带入，并忽略与 $u$ 无关的项，就能简化得到 $\\min_u \\cos \\theta$。这在 $u$ 与梯度方向相反时取得最小。换句话说，梯度向量指向上坡，负梯度向量指向下坡。我们在负梯度方向上移动可以减小 $f$。这就是梯度下降法(gradient descent)，也称最速下降法(method of steepest descent)。最速下降法建议新的点为$$x’=x-\\epsilon{\\nabla}_{x}f(x)$$其中 $\\epsilon$ 为学习率(learning rate)，是一个确定步长大小的正标量。我们可以通过几种不同的方式选择 $\\epsilon$。普遍的方式是选择一个小常数。有时我们通过计算，选择使方向导数消失的步长。还有一种方法是根据几个 $\\epsilon$ 计算 $f(x-\\epsilon{\\nabla}_{x}f(x))$,并选择其中能产生最小目标函数值的 $\\epsilon$。这种策略是线搜索。回到上面的题，求 $y=x^{2}+2x+e^{x}+3$ 的最小值。首先我们先随机初始化一个点 $x_0=0$ ，设置学习率 $\\epsilon=0.3$,其次，计算梯度 ${\\nabla}_{x}f(x)=\\frac{\\mathrm{d}y}{\\mathrm{d}x}=2x+2+e^x$。之后的计算交给MATLAB，代码如下： 12345678910111213x = 0.0; %初始化值c = 0.5; %设置学习率fprintf('n\\t\\t更新前的点\\t\\t梯度\\t\\t更新后的点\\n');for n = 1 : 10 xold = x; %本次循环前的 xt 值 grad = 2*x+2+exp(x); %梯度 xnew = x - c*grad; %梯度下降法更新后的点 fprintf('%d\\t\\t%6.2f\\t\\t%6.2f\\t\\t%6.2f\\n',n,xold,grad,xnew); x = xnew;end 得到结果如下： n 更新前的点 梯度 更新后的点 1 0.00 3.00 -1.50 2 -1.50 -0.78 -1.11 3 -1.11 -0.11 -1.16 4 -1.16 -0.02 -1.16 5 -1.16 -0.00 -1.16 6 -1.16 -0.00 -1.16 7 -1.16 -0.00 -1.16 8 -1.16 -0.00 -1.16 9 -1.16 -0.00 -1.16 10 -1.16 -0.00 -1.16 从上表中可以看到，在第4次循环后，$x’$ 的值不再改变，收敛于 $x=-1.16$，即，当 $x=-1.16$ 时，y取得最小值为 $y_{min}=(-1.16)^2+2*(-1.16)+e^{-1.16}+3=2.33908$ 矩阵求解(待更新)极大似然估计熵的原理启发式算法","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://eyum.top/categories/Algorithm/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"https://eyum.top/tags/Machine-learning/"},{"name":"Math","slug":"Math","permalink":"https://eyum.top/tags/Math/"},{"name":"Deep learning","slug":"Deep-learning","permalink":"https://eyum.top/tags/Deep-learning/"}]},{"title":"Android-action","slug":"Android-action","date":"2019-10-16T14:40:39.000Z","updated":"2020-07-08T09:11:30.372Z","comments":true,"path":"2019/10/16/Android-action/","link":"","permalink":"https://eyum.top/2019/10/16/Android-action/","excerpt":"","text":"编写一个MainActivity和MyService，在MainActivity中的onCreate()函数中为两个按钮分别设置点击事件监听器，点击第一个按钮启动服务弹出一个Toast显示“您点击了第一个按钮”，点击第二个按钮启动服务弹出一个Toast显示“您点击了第二个按钮”。（以action区分不同的动作） MainActivity.java 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final Button button1 = findViewById(R.id.button1); Button button2 = findViewById(R.id.button2); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this, MyService.class); intent.setAction(\"ACTION_BUTTON_1\"); startService(intent); &#125; &#125;); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this, MyService.class); intent.setAction(\"ACTION_BUTTON_2\"); startService(intent); &#125; &#125;); &#125;&#125; MyService.java 1234567891011121314151617181920public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; throw new UnsupportedOperationException(\"Not yet implemented\"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; String intentAction = intent.getAction(); if (intentAction.equals(\"ACTION_BUTTON_1\")) &#123; Toast.makeText(this, \"您点击了第一个按钮\", Toast.LENGTH_LONG).show(); &#125; else if (intentAction.equals(\"ACTION_BUTTON_2\")) &#123; Toast.makeText(this, \"您点击了第二个按钮\", Toast.LENGTH_LONG).show(); &#125; return super.onStartCommand(intent, flags, startId); &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://eyum.top/tags/Android/"}]},{"title":"Desktop icons don't appear","slug":"Desktop-icons-don-t-appear","date":"2019-10-12T14:59:22.000Z","updated":"2020-01-28T12:55:40.105Z","comments":true,"path":"2019/10/12/Desktop-icons-don-t-appear/","link":"","permalink":"https://eyum.top/2019/10/12/Desktop-icons-don-t-appear/","excerpt":"","text":"Debian 10 无桌面图标 (PS : 本文嵌入了一段 YouTube 视频，自行科学上网)环境如下:OS : Debian 10GNOME : 3.30.2 Debian 10 刚安装完后是这样的，未显示桌面图标：![Debian 10.png](Debian 10.png)最终在这篇文章中找到了原因：原文链接 No-desktop-icons.png 具体原因为，之前 GNOME 的 Desktop 是由 Nautilus 管理的，而现在开发者不维护了。在 YouTube 上找到了解决方案：视频链接 可以通过 Firefox 插件来解决，如下图： Applications-Menu.png Debian-10.png","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://eyum.top/tags/Linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-23T12:44:22.000Z","updated":"2020-01-28T13:02:30.806Z","comments":true,"path":"2019/09/23/hello-world/","link":"","permalink":"https://eyum.top/2019/09/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}